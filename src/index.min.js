const vertexShader="\nprecision mediump float;\n\nattribute float index;\nattribute float totalIndex;\nattribute vec3 position;\nattribute vec2 uv;\nattribute vec2 size;\nattribute vec2 offset;\nattribute vec2 padding;\nattribute vec3 bgColor;\nattribute vec3 textColor;\nattribute float direction;\nattribute float ratio;\nattribute vec2 weight;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float time;\nuniform float uWidth;\nuniform float uHeight;\nuniform float duration;\n\nvarying float vIndex;\nvarying float vTotalIndex;\nvarying vec2 vUv;\nvarying vec3 vBgColor;\nvarying vec3 vTextColor;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying vec2 vWeight;\n\nvoid main() {\n    vIndex = index;\n    vTotalIndex = totalIndex;\n    vUv = uv;\n    vBgColor = bgColor;\n    vTextColor = textColor;\n    vResolution = vec2(size.x - padding.x, size.y - padding.y);\n    vDirection = direction;\n    vRatio = ratio;\n    vWeight = weight;\n\n    float t = time / duration;\n\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    mvPosition.xy += offset * vResolution;\n\n    gl_Position = projectionMatrix * mvPosition;\n}",fragmentShader="\nprecision mediump float;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D texture;\nuniform vec2 textureResolution;\nuniform float textureBlockSize;\n\nvarying float vIndex;\nvarying float vTotalIndex;\nvarying vec2 vUv;\nvarying vec3 vBgColor;\nvarying vec3 vTextColor;\nvarying vec2 vResolution;\nvarying float vDirection;\nvarying float vRatio;\nvarying vec2 vWeight;\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat atan2(float y, float x){\n    return x == 0.0 ? sign(y) * PI / 2.0 : atan(y, x);\n}\n\n/**\n * Reference\n * https://karanokan.info/2019/03/31/post-2465\n */\nfloat polygon(vec2 p, float n, float size){\n    float a = atan2(p.x, p.y) + PI;\n    float r = 2.0 * PI / n;\n    return cos(floor(0.5 + a / r) * r - a) * length(p) - size;\n}\n\nvec2 getUVForTexture (vec2 uv, float t) {\n    float count = textureBlockSize;\n    vec2 pos = vec2(\n        floor(fract(t) * count),\n        floor(mod(t, count))\n    );\n    vec2 eachSize = textureResolution / count / textureResolution;\n    vec2 ff = vec2(pos.x, pos.y);\n\n    return vec2(\n        uv.x * eachSize.x + eachSize.x * ff.x,\n        uv.y * eachSize.y + (1.0 - eachSize.y) - eachSize.y * ff.y\n    );\n}\n\nfloat getTypePos(float index) {\n    return index / textureBlockSize;\n}\n\nvoid main() {\n    vec2 uv = (vUv.xy * vResolution * 2.0 - vResolution.xy) / min(vResolution.x, vResolution.y);\n    bool isOver = abs(uv.x) > 1.0 || abs(uv.y) > 1.0;\n    uv = uv * 0.5 + 0.5;\n\n    float count = textureBlockSize;\n    float totalCount = count * count;\n\n    vec2 weight = (vWeight * resolution * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n    vec2 ratio = vec2(\n        max((vResolution.x / vResolution.y) / (textureResolution.x / textureResolution.y), 1.0),\n        max((vResolution.y / vResolution.x) / (textureResolution.y / textureResolution.x), 1.0)\n    );\n\n    // Triangle\n//    float triangle = polygon(weight, 3.0, 0.0);\n//    float n = 3.0;\n//    triangle = fract(triangle * n - time);\n//    float t = 1.0 - step(0.7, triangle);\n//    t = mix(getTypePos(0.0), getTypePos(mod(time + rand(weight)*30.0, totalCount) + 1.0), t);\n\n    // Ellipse\n    float t = -length(weight * 2.0) + time;\n\n    vec2 uvForTex = getUVForTexture(uv, t);\n\n    vec3 bgColor = vBgColor;\n    vec3 txtColor = vTextColor;\n    vec4 tex = texture2D(texture, uvForTex);\n    vec3 color = mix(bgColor, txtColor, tex.rgb);\n    color = mix(bgColor, tex.rgb, step(0.1, t));\n\n    if (isOver) {\n        color = bgColor;\n    }\n\n    gl_FragColor = vec4(color, 1.0);\n}";let renderer,scene,geometry;const index=[],vertices=[],uvs=[],offsets=[],indices=[],paddings=[],bgColors=[],textColors=[],size=[],directions=[],ratios=[],weights=[],palettes=[{hexColor:"#020402",glColor:{},name:"Black"},{hexColor:"#c52233",glColor:{},name:"Cardinal"},{hexColor:"#5b2a86",glColor:{},name:"KSU Purple"},{hexColor:"#eeba0b",glColor:{},name:"Orange Yellow"},{hexColor:"#1098f7",glColor:{},name:"Dodger Blue"},{hexColor:"#00ffc5",glColor:{},name:"Sea Green Crayola"}],texts=["コード💻で切り拓く、アート🖼の新たな地平🌅。","Gen Art 🖥 is the future🚀.","@!+-?*/,[=}%:~&#_;*[>.$(¥","🐻 KUMA 🌈 熊 🎌 くま 🧸 BEAR 🎨"];let baseTile,uniforms,attr,totalRenderCount=0,lastUpdatedTime=0,currentTime=[0];class Random{constructor(hash){this.useA=!1;let sfc32=function(uint128Hex){let a=parseInt(uint128Hex.substr(0,8),16),b=parseInt(uint128Hex.substr(8,8),16),c=parseInt(uint128Hex.substr(16,8),16),d=parseInt(uint128Hex.substr(24,8),16);return function(){a|=0,b|=0,c|=0,d|=0;let t=(a+b|0)+d|0;return d=d+1|0,a=b^b>>>9,b=c+(c<<3)|0,c=c<<21|c>>>11,c=c+t|0,(t>>>0)/4294967296}};this.prngA=new sfc32(hash.substr(2,32)),this.prngB=new sfc32(hash.substr(34,32));for(let i=0;i<1e6;i+=2)this.prngA(),this.prngB()}random_dec(){return this.useA=!this.useA,this.useA?this.prngA():this.prngB()}random_num(a,b){return a+(b-a)*this.random_dec()}random_int(a,b){return Math.floor(this.random_num(a,b+1))}random_bool(p){return this.random_dec()<p}random_choice(list){return list[this.random_int(0,list.length-1)]}}const hexToGL=hexStr=>{if(/^#([0-9A-F]{3}){1,2}$/i.test(hexStr)){let out=new THREE.Color(hexStr).toArray().map((x=>{let conv=Math.round(1e3*x)/1e3;return-1===conv.toString().indexOf(".")&&(conv+=".0",conv=parseFloat(conv)),conv}));return{r:out[0],g:out[1],b:out[2]}}return{r:0,g:0,b:0}},glToHex=arr=>{arr=[arr.r,arr.g,arr.b];for(let val of arr)if(val>1||val<0)return"";return`#${(new THREE.Color).fromArray(arr).getHexString()}`},getPalette=colorId=>{const palette=palettes[colorId%palettes.length];return palette.glColor=hexToGL(palette.hexColor),palette},randomHash=()=>{let result="0x";for(let i=0;i<64;i++)result+=Math.floor(16*Math.random()).toString(16);return result},hash=randomHash(),random=new Random(hash),renderTiles=()=>{renderer=new THREE.WebGLRenderer,scene=new THREE.Scene;const bgColor=getTextColor(attr.bgColor.glColor);scene.background=new THREE.Color(bgColor),geometry=new THREE.BufferGeometry,geometry.setIndex(indices),geometry.setAttribute("index",new THREE.Uint16BufferAttribute(index,1)),geometry.setAttribute("totalIndex",new THREE.Float32BufferAttribute([...Array(index.length)].map(((_,index)=>totalRenderCount)),1)),geometry.setAttribute("position",new THREE.Float32BufferAttribute(vertices,3)),geometry.setAttribute("uv",new THREE.Uint16BufferAttribute(uvs,2)),geometry.setAttribute("size",new THREE.Float32BufferAttribute(size,2)),geometry.setAttribute("offset",new THREE.Float32BufferAttribute(offsets,2)),geometry.setAttribute("padding",new THREE.Float32BufferAttribute(paddings,2)),geometry.setAttribute("bgColor",new THREE.Float32BufferAttribute(bgColors,3)),geometry.setAttribute("textColor",new THREE.Float32BufferAttribute(textColors,3)),geometry.setAttribute("direction",new THREE.Float32BufferAttribute(directions,1)),geometry.setAttribute("ratio",new THREE.Float32BufferAttribute(ratios,1)),geometry.setAttribute("weight",new THREE.Float32BufferAttribute(weights,2));const material=new THREE.RawShaderMaterial({uniforms:uniforms,vertexShader:vertexShader,fragmentShader:fragmentShader,transparent:!0,blending:THREE.NormalBlending,depthTest:!0,wireframe:!1,glslVersion:THREE.GLSL1}),mesh=new THREE.Mesh(geometry,material);scene.add(mesh)},getTextColor=glColor=>.299*glColor.r+.587*glColor.g+.114*glColor.b<80/255?"#ffffff":"#000000",createTextTexture=()=>{let originalText=attr.text,_originalText=Array.from(originalText).slice(0,25);for(;_originalText.length<25;)_originalText.push("　");const canvas=document.createElement("canvas");canvas.width=1e3,canvas.height=1e3;const ctx=canvas.getContext("2d");ctx.font="160px 'Arial'";const bgColor=attr.bgColor;ctx.fillStyle=bgColor.hexColor,ctx.fillRect(0,0,canvas.width,canvas.height),ctx.fillStyle=getTextColor(bgColor.glColor),ctx.textAlign="center",ctx.textBaseline="middle";for(let i=0;i<_originalText.length;i++){const x=i%5*200+100,y=200*Math.floor(i/5)+100;ctx.fillText(_originalText[i],x,y)}const texture=new THREE.Texture(canvas);texture.needsUpdate=!0,uniforms.texture.value=texture,uniforms.textureResolution.value=new THREE.Vector2(canvas.width,canvas.height),uniforms.textureBlockSize.value=5},getMetadataAttributes=()=>({Text:attr.text,BackgroundColor:attr.bgColor.name,TileRatioOffset:attr.tileRatioOffset,Dynamic:attr.dynamic,Division:attr.division,Divider:attr.divider>0}),createTiles=()=>{attr={text:random.random_choice(texts),textColor:hexToGL("#ffffff"),bgColor:getPalette(random.random_int(0,palettes.length)),tileRatioOffset:random.random_num(0,.2),dynamic:random.random_bool(.1),division:random.random_int(10,12),divider:random.random_bool(.1)?.8:0},console.log({Text:attr.text,BackgroundColor:attr.bgColor.name,TileRatioOffset:attr.tileRatioOffset,Dynamic:attr.dynamic,Division:attr.division,Divider:attr.divider>0}),uniforms={time:{type:"f",value:1},resolution:{type:"v2",value:new THREE.Vector2},texture:{type:"t",value:null},textureResolution:{type:"v2",value:new THREE.Vector2},textureBlockSize:{type:"f",value:1},forceRadius:{value:1},pointerForce:{value:1},pointerForceFactor:{value:0},pointerPos:{value:new THREE.Vector2}},baseTile=new Tile(-window.innerWidth/2,-window.innerHeight/2,window.innerWidth,window.innerHeight,0),renderTiles(),createTextTexture()};class Tile{constructor(x,y,w,h,age){if(this.x=x,this.y=y,this.w=w,this.h=h,this.age=age,this.children=[],this.offset=Math.floor(50*Math.random()+1),this.ratio=.5+(2*Math.random()-1)*attr.tileRatioOffset,this.targetRatio=this.ratio,this.shouldRender=!1,this.id=-1,this.impulse=0,this.updateCount=0,this.age<attr.division){const nextAge=this.age+1;if(this.age%2==0){const w1=this.w*this.ratio,w2=this.w*(1-this.ratio);this.children[0]=new Tile(this.x,this.y,w1,this.h,nextAge),this.children[1]=new Tile(this.x+w1,this.y,w2,this.h,nextAge)}else{const h1=this.h*this.ratio,h2=this.h*(1-this.ratio);this.children[0]=new Tile(this.x,this.y,this.w,h1,nextAge),this.children[1]=new Tile(this.x,this.y+h1,this.w,h2,nextAge)}}else this.draw(!1)}updateTarget(ratio){if(this.children.length>0){this.targetRatio=ratio||Math.random();const _ratio=ratio||null;this.children[0].updateTarget(_ratio),this.children[1].updateTarget(_ratio)}}update(arg=null){if(arg&&(this.x=arg.x,this.y=arg.y,this.w=arg.w,this.h=arg.h,this.impulse=arg.impulse),this.children.length>0){let ratioDiff=Math.abs(this.ratio-this.targetRatio);ratioDiff<.002&&(this.targetRatio=Math.random(),this.updateCount++),ratioDiff<.005&&(ratioDiff=0);const duration=.5,speed=.1,r=Math.max(Math.min(Math.abs(this.targetRatio-this.ratio)/duration,speed),0);if(this.ratio+=(this.targetRatio-this.ratio)*r,this.ratio=Math.max(Math.min(this.ratio,1),0),this.age%2==0){const x1=this.x,y1=this.y,w1=this.w*this.ratio,h1=this.h;this.children[0].update({x:x1,y:y1,w:w1,h:h1,impulse:ratioDiff});const x2=x1+w1,y2=y1,w2=this.w*(1-this.ratio),h2=this.h;this.children[1].update({x:x2,y:y2,w:w2,h:h2,impulse:ratioDiff})}else{const x1=this.x,y1=this.y,w1=this.w,h1=this.h*this.ratio;this.children[0].update({x:x1,y:y1,w:w1,h:h1,impulse:ratioDiff});const x2=this.x,y2=this.y+h1,w2=this.w,h2=this.h*(1-this.ratio);this.children[1].update({x:x2,y:y2,w:w2,h:h2,impulse:ratioDiff})}}else this.draw(!0)}resize(arg){if(this.x=arg.x,this.y=arg.y,this.w=arg.w,this.h=arg.h,this.children.length>0)if(this.age%2==0){const x1=this.x,y1=this.y,w1=this.w*this.ratio,h1=this.h;this.children[0].resize({x:x1,y:y1,w:w1,h:h1});const x2=x1+w1,y2=y1,w2=this.w*(1-this.ratio),h2=this.h;this.children[1].resize({x:x2,y:y2,w:w2,h:h2})}else{const x1=this.x,y1=this.y,w1=this.w,h1=this.h*this.ratio;this.children[0].resize({x:x1,y:y1,w:w1,h:h1});const x2=this.x,y2=this.y+h1,w2=this.w,h2=this.h*(1-this.ratio);this.children[1].resize({x:x2,y:y2,w:w2,h:h2})}else this.draw(!0)}draw(shouldUpdate=!1){if(this.shouldRender=!0,shouldUpdate){const screenPos=this.getDistanceFromScreenCenter();for(let j=0;j<4;j++){const targetIndex=4*this.id+j,position=geometry.attributes.position;position.setXYZ(targetIndex,this.x,this.y,0),position.needsUpdate=!0;const size=geometry.attributes.size;size.setXY(targetIndex,this.w,this.h),size.needsUpdate=!0;const ratio=geometry.attributes.ratio;ratio.setX(targetIndex,this.impulse),ratio.needsUpdate=!0;const direction=geometry.attributes.direction;direction.setX(targetIndex,this.getDirection()),direction.needsUpdate=!0;const weight=geometry.attributes.weight;weight.setXY(targetIndex,screenPos.x,screenPos.y),weight.needsUpdate=!0}}else{this.id=totalRenderCount;const screenPos=this.getDistanceFromScreenCenter();for(let j=0;j<4;j++)vertices.push(this.x,this.y,0),size.push(this.w,this.h),directions.push(this.getDirection()),ratios.push(this.ratio),weights.push(screenPos.x,screenPos.y);const bgColor=attr.bgColor.glColor;for(let j=0;j<4;j++)index.push(this.id),paddings.push(attr.divider,attr.divider),bgColors.push(bgColor.r,bgColor.g,bgColor.b),textColors.push(attr.textColor.r,attr.textColor.g,attr.textColor.b);uvs.push(0,0,1,0,1,1,0,1),offsets.push(0,0,1,0,1,1,0,1);const vertexIndex=4*this.id;indices.push(vertexIndex+0,vertexIndex+1,vertexIndex+2,vertexIndex+2,vertexIndex+3,vertexIndex+0),totalRenderCount++}}getDirection(){return Math.abs(this.w-this.h)<100?-1:this.w>this.h?1:0}getCenter(){return{x:this.x+this.w/2,y:this.y+this.h/2}}getDistanceFromScreenCenter(){const centerOfTile=this.getCenter(),w=window.innerWidth,h=window.innerHeight;return{x:(centerOfTile.x+w/2)/w,y:(centerOfTile.y+h/2)/h}}}let camera,pointerPos,clock,pixelRatio=1,isPointerActive=!1;const FORCE_RADIUS=800,POINTER_FORCE=400;kumaleon.options={onInit:()=>{camera=new THREE.OrthographicCamera(-1,1,1,-1,.1,4),camera.position.z=2,camera.lookAt(0,0,0),camera.matrixAutoUpdate=!1,clock=new THREE.Clock,attr={text:random.random_choice(texts),textColor:hexToGL("#ffffff"),bgColor:getPalette(random.random_int(0,palettes.length)),tileRatioOffset:random.random_num(0,.2),dynamic:random.random_bool(.1),division:random.random_int(10,12),divider:random.random_bool(.1)?.8:0},console.log({Text:attr.text,BackgroundColor:attr.bgColor.name,TileRatioOffset:attr.tileRatioOffset,Dynamic:attr.dynamic,Division:attr.division,Divider:attr.divider>0}),uniforms={time:{type:"f",value:1},resolution:{type:"v2",value:new THREE.Vector2},texture:{type:"t",value:null},textureResolution:{type:"v2",value:new THREE.Vector2},textureBlockSize:{type:"f",value:1},forceRadius:{value:1},pointerForce:{value:1},pointerForceFactor:{value:0},pointerPos:{value:new THREE.Vector2}},baseTile=new Tile(-window.innerWidth/2,-window.innerHeight/2,window.innerWidth,window.innerHeight,0),renderTiles(),createTextTexture();const canvas=renderer.domElement;document.querySelector(".js-main").appendChild(canvas),pointerPos=new THREE.Vector2,window.addEventListener("pointermove",(e=>{pointerPos.x=e.clientX,pointerPos.y=e.clientY,isPointerActive=!0})),kumaleon.setCanvas(canvas)},onUpdate:()=>{uniforms.pointerPos.value.x=pointerPos.x*pixelRatio,uniforms.pointerPos.value.y=pointerPos.y*pixelRatio,isPointerActive&&(uniforms.pointerForceFactor.value+=.1*(1-uniforms.pointerForceFactor.value));const time=clock.getElapsedTime();if(uniforms.time.value=time,currentTime[0]=time,uniforms.forceRadius.value=800*pixelRatio,uniforms.pointerForce.value=400*pixelRatio,baseTile&&attr.dynamic){baseTile.update();const sec=Math.floor(currentTime[0]);(0===sec||sec!==lastUpdatedTime&&sec%10==0)&&(baseTile.updateTarget(.5),lastUpdatedTime=sec)}renderer.render(scene,camera)},onResize:()=>{pixelRatio=Math.min(2,window.devicePixelRatio);const w=window.innerWidth,h=window.innerHeight,halfW=.5*w,halfH=.5*h;camera.left=-halfW,camera.right=halfW,camera.top=halfH,camera.bottom=-halfH,camera.updateProjectionMatrix(),uniforms.resolution.value.x=w*pixelRatio,uniforms.resolution.value.y=h*pixelRatio,renderer.setPixelRatio(pixelRatio),renderer.setSize(w,h),baseTile&&baseTile.resize({x:-window.innerWidth/2,y:-window.innerHeight/2,w:window.innerWidth,h:window.innerHeight})}};
